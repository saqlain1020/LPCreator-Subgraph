// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class LiquidityAdded extends ethereum.Event {
  get params(): LiquidityAdded__Params {
    return new LiquidityAdded__Params(this);
  }
}

export class LiquidityAdded__Params {
  _event: LiquidityAdded;

  constructor(event: LiquidityAdded) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount1(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _amount2(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class LiquidityWithdrawn extends ethereum.Event {
  get params(): LiquidityWithdrawn__Params {
    return new LiquidityWithdrawn__Params(this);
  }
}

export class LiquidityWithdrawn__Params {
  _event: LiquidityWithdrawn;

  constructor(event: LiquidityWithdrawn) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount1(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _amount2(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _lpTokens(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Pool extends ethereum.SmartContract {
  static bind(address: Address): Pool {
    return new Pool("Pool", address);
  }

  addLiquidity(_amount1: BigInt, _amount2: BigInt): boolean {
    let result = super.call(
      "addLiquidity",
      "addLiquidity(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(_amount1),
        ethereum.Value.fromUnsignedBigInt(_amount2)
      ]
    );

    return result[0].toBoolean();
  }

  try_addLiquidity(
    _amount1: BigInt,
    _amount2: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "addLiquidity",
      "addLiquidity(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(_amount1),
        ethereum.Value.fromUnsignedBigInt(_amount2)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  feeDecimals(): BigInt {
    let result = super.call("feeDecimals", "feeDecimals():(uint256)", []);

    return result[0].toBigInt();
  }

  try_feeDecimals(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("feeDecimals", "feeDecimals():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  feePercent(): BigInt {
    let result = super.call("feePercent", "feePercent():(uint256)", []);

    return result[0].toBigInt();
  }

  try_feePercent(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("feePercent", "feePercent():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  flashSwap(
    account: Address,
    _amount: BigInt,
    _requiredAmount2: BigInt,
    _sendingToken: i32,
    data: Bytes
  ): boolean {
    let result = super.call(
      "flashSwap",
      "flashSwap(address,uint256,uint256,uint8,bytes):(bool)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromUnsignedBigInt(_requiredAmount2),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_sendingToken)),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBoolean();
  }

  try_flashSwap(
    account: Address,
    _amount: BigInt,
    _requiredAmount2: BigInt,
    _sendingToken: i32,
    data: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "flashSwap",
      "flashSwap(address,uint256,uint256,uint8,bytes):(bool)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromUnsignedBigInt(_requiredAmount2),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_sendingToken)),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lpToken(): Address {
    let result = super.call("lpToken", "lpToken():(address)", []);

    return result[0].toAddress();
  }

  try_lpToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("lpToken", "lpToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  lpTokenBalanceOf(_account: Address): BigInt {
    let result = super.call(
      "lpTokenBalanceOf",
      "lpTokenBalanceOf(address):(uint256)",
      [ethereum.Value.fromAddress(_account)]
    );

    return result[0].toBigInt();
  }

  try_lpTokenBalanceOf(_account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lpTokenBalanceOf",
      "lpTokenBalanceOf(address):(uint256)",
      [ethereum.Value.fromAddress(_account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lpTokenSupply(): BigInt {
    let result = super.call("lpTokenSupply", "lpTokenSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lpTokenSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lpTokenSupply",
      "lpTokenSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  productConstant(): BigInt {
    let result = super.call(
      "productConstant",
      "productConstant():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_productConstant(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "productConstant",
      "productConstant():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reserveToken1(): BigInt {
    let result = super.call("reserveToken1", "reserveToken1():(uint256)", []);

    return result[0].toBigInt();
  }

  try_reserveToken1(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reserveToken1",
      "reserveToken1():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reserveToken2(): BigInt {
    let result = super.call("reserveToken2", "reserveToken2():(uint256)", []);

    return result[0].toBigInt();
  }

  try_reserveToken2(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reserveToken2",
      "reserveToken2():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  resultingTokens(_amount: BigInt, _sendingToken: i32): BigInt {
    let result = super.call(
      "resultingTokens",
      "resultingTokens(uint256,uint8):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_sendingToken))
      ]
    );

    return result[0].toBigInt();
  }

  try_resultingTokens(
    _amount: BigInt,
    _sendingToken: i32
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "resultingTokens",
      "resultingTokens(uint256,uint8):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_sendingToken))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swap(account: Address, _amount: BigInt, _sendingToken: i32): boolean {
    let result = super.call("swap", "swap(address,uint256,uint8):(bool)", [
      ethereum.Value.fromAddress(account),
      ethereum.Value.fromUnsignedBigInt(_amount),
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_sendingToken))
    ]);

    return result[0].toBoolean();
  }

  try_swap(
    account: Address,
    _amount: BigInt,
    _sendingToken: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("swap", "swap(address,uint256,uint8):(bool)", [
      ethereum.Value.fromAddress(account),
      ethereum.Value.fromUnsignedBigInt(_amount),
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_sendingToken))
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  token1(): Address {
    let result = super.call("token1", "token1():(address)", []);

    return result[0].toAddress();
  }

  try_token1(): ethereum.CallResult<Address> {
    let result = super.tryCall("token1", "token1():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  token1Address(): Address {
    let result = super.call("token1Address", "token1Address():(address)", []);

    return result[0].toAddress();
  }

  try_token1Address(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "token1Address",
      "token1Address():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  token1Balance(): BigInt {
    let result = super.call("token1Balance", "token1Balance():(uint256)", []);

    return result[0].toBigInt();
  }

  try_token1Balance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "token1Balance",
      "token1Balance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token1Name(): string {
    let result = super.call("token1Name", "token1Name():(string)", []);

    return result[0].toString();
  }

  try_token1Name(): ethereum.CallResult<string> {
    let result = super.tryCall("token1Name", "token1Name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  token2(): Address {
    let result = super.call("token2", "token2():(address)", []);

    return result[0].toAddress();
  }

  try_token2(): ethereum.CallResult<Address> {
    let result = super.tryCall("token2", "token2():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  token2Address(): Address {
    let result = super.call("token2Address", "token2Address():(address)", []);

    return result[0].toAddress();
  }

  try_token2Address(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "token2Address",
      "token2Address():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  token2Balance(): BigInt {
    let result = super.call("token2Balance", "token2Balance():(uint256)", []);

    return result[0].toBigInt();
  }

  try_token2Balance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "token2Balance",
      "token2Balance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token2Name(): string {
    let result = super.call("token2Name", "token2Name():(string)", []);

    return result[0].toString();
  }

  try_token2Name(): ethereum.CallResult<string> {
    let result = super.tryCall("token2Name", "token2Name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  withdrawLiquidity(): boolean {
    let result = super.call(
      "withdrawLiquidity",
      "withdrawLiquidity():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_withdrawLiquidity(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "withdrawLiquidity",
      "withdrawLiquidity():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _token1(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token2(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _name1(): string {
    return this._call.inputValues[2].value.toString();
  }

  get _name2(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddLiquidityCall extends ethereum.Call {
  get inputs(): AddLiquidityCall__Inputs {
    return new AddLiquidityCall__Inputs(this);
  }

  get outputs(): AddLiquidityCall__Outputs {
    return new AddLiquidityCall__Outputs(this);
  }
}

export class AddLiquidityCall__Inputs {
  _call: AddLiquidityCall;

  constructor(call: AddLiquidityCall) {
    this._call = call;
  }

  get _amount1(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _amount2(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AddLiquidityCall__Outputs {
  _call: AddLiquidityCall;

  constructor(call: AddLiquidityCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class DestroyContractCall extends ethereum.Call {
  get inputs(): DestroyContractCall__Inputs {
    return new DestroyContractCall__Inputs(this);
  }

  get outputs(): DestroyContractCall__Outputs {
    return new DestroyContractCall__Outputs(this);
  }
}

export class DestroyContractCall__Inputs {
  _call: DestroyContractCall;

  constructor(call: DestroyContractCall) {
    this._call = call;
  }
}

export class DestroyContractCall__Outputs {
  _call: DestroyContractCall;

  constructor(call: DestroyContractCall) {
    this._call = call;
  }
}

export class FlashSwapCall extends ethereum.Call {
  get inputs(): FlashSwapCall__Inputs {
    return new FlashSwapCall__Inputs(this);
  }

  get outputs(): FlashSwapCall__Outputs {
    return new FlashSwapCall__Outputs(this);
  }
}

export class FlashSwapCall__Inputs {
  _call: FlashSwapCall;

  constructor(call: FlashSwapCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _requiredAmount2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _sendingToken(): i32 {
    return this._call.inputValues[3].value.toI32();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class FlashSwapCall__Outputs {
  _call: FlashSwapCall;

  constructor(call: FlashSwapCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SwapCall extends ethereum.Call {
  get inputs(): SwapCall__Inputs {
    return new SwapCall__Inputs(this);
  }

  get outputs(): SwapCall__Outputs {
    return new SwapCall__Outputs(this);
  }
}

export class SwapCall__Inputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _sendingToken(): i32 {
    return this._call.inputValues[2].value.toI32();
  }
}

export class SwapCall__Outputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawLiquidityCall extends ethereum.Call {
  get inputs(): WithdrawLiquidityCall__Inputs {
    return new WithdrawLiquidityCall__Inputs(this);
  }

  get outputs(): WithdrawLiquidityCall__Outputs {
    return new WithdrawLiquidityCall__Outputs(this);
  }
}

export class WithdrawLiquidityCall__Inputs {
  _call: WithdrawLiquidityCall;

  constructor(call: WithdrawLiquidityCall) {
    this._call = call;
  }
}

export class WithdrawLiquidityCall__Outputs {
  _call: WithdrawLiquidityCall;

  constructor(call: WithdrawLiquidityCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
